
<html>
<head>
  <title>TensorFlow.js: Using a pretrained MobileNet</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"> </script>



</head>

<style>
  .pred-container {
    margin-bottom: 20px;
  }

  .pred-container > div {
    display: inline-block;
    margin-right: 20px;
    vertical-align: top;
  }

  .row {
    display: table-row;
  }
  .cell {
    display: table-cell;
    padding-right: 20px;
  }

  #file-container {
    margin-bottom: 20px;
  }
</style>

<body>
    <section>
      <p >Status</p>
      <p id="status"></p>
    </section>

    <section>
      <p class='section-head'>Model Output</p>

      <div id="file-container">
        Upload an image: 
        <input type="file" id="files" name="files[]" multiple />
      </div>

      <div id="predictions"></div>

      <!-- <img style="display: none" id="cat" src="cat.jpg" width=224 height=224 /> -->
    </section>

    <!-- <script src="./js/scripts.js" type=module></script> -->

<script>
const predictionsElement = document.getElementById('predictions');    
const demoStatusElement = document.getElementById('status');
const status = msg => demoStatusElement.innerText = msg;
const MODEL_PATH = './Model/model.json';
const IMAGE_SIZE = 256;
status('Loading model...');

async function predict(imgElement) {
    status('Predicting...');
    const img = tf.browser.fromPixels(imgElement).toFloat();    
    const offset = tf.scalar(127.5);
    const normalized = img.sub(offset).div(offset);
    const batched = normalized.reshape([1, IMAGE_SIZE, IMAGE_SIZE, 3]);
    return model.predict(batched);
};

function showResults(imgElement) {
  const predictionContainer = document.createElement('div');
  predictionContainer.className = 'pred-container';

  const imgContainer = document.createElement('div');
  imgContainer.appendChild(imgElement);
  predictionContainer.appendChild(imgContainer);
  predictionsElement.insertBefore(predictionContainer, predictionsElement.firstChild);
}

const filesElement = document.getElementById('files');
filesElement.addEventListener('change', evt => {
  let files = evt.target.files;
  // Display thumbnails & issue call to predict each image.
  for (let i = 0, f; f = files[i]; i++) {
    // Only process image files (skip non image files)
    if (!f.type.match('image.*')) {
      continue;
    }
    let reader = new FileReader();
    reader.onload = e => {
      // Fill the image & call predict.
      let img = document.createElement('img');
      img.src = e.target.result;
      img.width = IMAGE_SIZE;
      img.height = IMAGE_SIZE;
      img.onload = () => showResults(img);
      predict(img);
    };

    // Read in the image file as a data URL.
    reader.readAsDataURL(f);
  }
});



model = tf.loadLayersModel(MODEL_PATH).then( model => {
  model.predict(tf.zeros([1, IMAGE_SIZE, IMAGE_SIZE, 3])).dispose();  
});
// model.predict(tf.zeros([1, IMAGE_SIZE, IMAGE_SIZE, 3])).dispose();
status('');

// console.log(model.summary())




</script>



</body>
</html>